# Основы ООП

---

## Содержание

1. [Введение](#введение)
2. [Объектно-ориентированные концепции](#объектно-ориентированные-концепции)
3. [Основные парадигмы](#основные-парадигмы)
4. [Ошибки OOP](#ошибки-в-ооп)
5. [Ковариантность, Контравариантность и Инвариантность](#ковариантность-контравариантность-и-инвариантность)
6. [Hexlet](#hexlet)

---

## Введение

`Объектно-ориентированное программирование` или сокращённо называемое `ООП` — это подход, который помогает
разрабатывать сложные приложения так, чтобы их можно было в течение длительного времени легко поддерживать и
масштабировать.

Кстати, изобретателем ООП является Алан Кей.

В процедурном программировании мы создаём структуры данных — числа, строки, массивы, а затем обрабатываем эти структуры
специальными функциями, которые манипулируют этими данными.

В мире ООП мы храним структуры данных и функции, их обрабатывающие, в одной сущности, называемой `объектом`. Вместо
того, чтобы обработать данные какой-либо функцией, мы загружаем эти данные в объект, а затем вызываем его методы для
манипулирования ими и получаем желаемый результат. Это отличается от процедурного программирования, когда мы, в первую
очередь, взаимодействуем с функциями и глобальными переменными.

Объектно-ориентированное программирование имеет несколько преимуществ перед процедурным программированием:

- ООП быстрее и проще в исполнении — позволяет мыслить категориями повседневных объектов, такие реальные понятия
  как `Person`, `Car` или `Animal` рассматриваются как объекты. Это во многом упрощает задачу, когда вы только начинаете
  проектировать свое приложение, так как назначение каждого объекта, так и цель отношений между объектами, будут
  логически понятны.
- Легче писать модульные программы — ООП предполагает написание модулей. Модульность упрощает обслуживание, изменение и
  отладку кода. Модульная структура позволяет вносить независимые изменения в разные части программы, сводя к минимуму
  риск ошибок программирования.
- ООП позволяет создавать полностью повторно используемые приложения с меньшим количеством кода и более коротким
  временем разработки. Со временем вы даже можете создать целую библиотеку такого рода модулей, которые в дальнейшем
  сможете использовать во многих приложениях. С помощью ООП становится сравнительно легче писать такой код, так как
  структуры данных и функции инкапсулируются в единственный объект, который можно использовать любое количество раз.

[⏏ К содержанию](#содержание)

## Объектно-ориентированные концепции

Прежде чем мы углубимся в детали ООП, давайте определим важные термины, относящиеся к объектно-ориентированному
программированию:

- **Класс** — это тип данных, определяемый программистом, который включает как локальные функции, так и локальные
  данные. Вы можете думать о классе как о **шаблоне для создания** множества экземпляров одного и того же вида (или
  класса) **объекта**. Класс ОПИСЫВАЕТСЯ. Класс определяется единожды

- **Объект** — отдельный **экземпляр** структуры данных, **определенной классом**. Вы определяете класс один раз, а
  затем создаете множество объектов, которые ему принадлежат. Объекты также известны как экземпляры.Объект СОЗДАЁТСЯ.
  Объект можно создавать, как правило, много раз. Сущность из реального мира.

❗ Отличия между классом и объектом:
Класс лишь определяет доступные поведения, методы, возможные состояния экземпляров класса (объектов), а сами объекты -
это конкретные экземпляры класса, в них мы можем вызывать методы, создавать переменные, при чем все они могут иметь
различные состояния, но будут контролироваться классом. Все доступные методы и поведение описано в классе, через объекты
происходит взаимодействие с классом и хранение данных.

- **Переменная-член** — это переменные, определенные внутри класса. Эти данные будут невидимы для внешнего класса, и к
  ним можно будет получить доступ через функции-члены. Эти переменные называются атрибутом объекта после создания
  объекта.

- **Функция-член** — это функция, определенная внутри класса и используемая для доступа к данным объекта.

- **Наследование** — когда класс определяется путем наследования существующей функции родительского класса, это
  называется наследованием. Здесь дочерний класс наследует все или несколько функций-членов и переменных родительского
  класса.

- **Композиция** - класс создает объект другого класса внутри себя и использует его поля и методы

- **Агрегация** - класс получает объект другого класса из вне и использует его поля и методы

- **Родительский класс** — класс, унаследованный от другого класса. Это также называется **базовым классом** или **
  суперклассом**.

- **Дочерний класс** — класс, наследуемый от другого класса. Это также называется **подклассом** или **производным
  классом**

- **Полиморфизм** — это объектно-ориентированная концепция, в которой одна и та же функция может использоваться для
  разных целей. Например, имя функции останется прежним, но она принимает другое количество аргументов и может выполнять
  разные задачи.

- **Перегрузка** — тип полиморфизма, при котором некоторые или все операторы имеют разные реализации в зависимости от
  типов их аргументов. Точно так же функции могут быть перегружены другой реализацией.

- **Абстракция данных** — любое представление данных, в котором детали реализации скрыты (абстрагированы).

- **Инкапсуляция** — относится к концепции, при которой мы инкапсулируем все данные и функции-члены вместе для
  формирования объекта.

- **Конструктор** — относится к особому типу функции, которая будет вызываться автоматически при формировании объекта из
  класса (инициализирует объект).

- **Деструктор** — относится к особому типу функции, которая будет вызываться автоматически всякий раз, когда объект
  удаляется или выходит за пределы области видимости.

- **Контравариантностью** - противоположное действие контравариантноси, которое позволяет нам делать даункаст, то есть
  приведение базового типа данных, к производному, опять же, в обобщенных типах это выражения.

- **Контравариантность** — перенос наследования исходных типов на производные от них типы в обратном порядке.

- **Инвариантность** — ситуация, когда наследование исходных типов не переносится на производные. (условие, которое
  остается истинным после вызова любых методов объекта в любой последовательности, либо (реже) выражение которое
  сохраняет свое значение после вызова любых методов.)

Итак, класс — это шаблон для объектов, а объект — это экземпляр класса. Когда создаются отдельные объекты, они наследуют
все свойства и поведение класса, но каждый объект будет иметь разные значения свойств.

[⏏ К содержанию](#содержание)

## Основные парадигмы

[//]: # (https://www.youtube.com/watch?v=BHNt1fcg8iw)

`Парадигма` - это стиль написания программ, подходы к написанию кода.

Парадигмы делятся на 2 типа: императивное и декларативное. Императивная парадигма программированию задает
последовательность команд, КАК надо что-то сделать, а декларативное - только то, ЧТО надо сделать.

> В общем и целом, декларативное программирование идёт от человека к машине, тогда как императивное — от машины к
> человеку.

Принципы ООП в том виде, который изначально планировал Алан Кей:

- Объект является базовой единицей объектно-ориентированной системы.
- Отправка сообщений - единственный способ обмена информацией между объектами.
- Каждый объект связан с некоторым классом.
- Поведение объекта определяется его классом.
- Классы наследуют свою функциональность от своего предка.
- Все является Объектом. Буквально все.

OOП помогает строить сложные системы более просто и естественно благодаря тому, что вся предметная область разбивается
на объекты и каждый из них слабо связан с другими объектами. Слабая связанность возникает вследствие соблюдения трех
принципов: инкапсуляции, наследования и полиморфизма.

1. `Инкапсуляция` – объединение данных и функций, управляющих этими данными, в единый компонент. Вторая интерпретация:
   Инкапсуляция - механизм языка, позволяющий ограничить доступность одних компонентов программы для других.

❗ Инкапсуляция обеспечивает сокрытие информации, но сама по себе не является сокрытием информации. (Сокрытие данных
достигается посредством модификаторов доступа ( private, public, protected, protected), каждый из которых определяет
свой уровень доступности членов типа)

2. `Наследование` - это механизм языка, который позволяет описать новый класс на основе существующего, что позволяет
   описать новый класс на основе существующего.

Многие люди при определении интерпретации говорят, что это помогает при повторном использовании кода. Просто чтобы им не
нужно было повторять определение метода, они могут просто замазать себя наследованием и все должно быть ок, хотя это
может быть достигается другими средствами.

Например: с помощью `агрегации` - класс получает объект другого класса из
вне и использует его поля и методы и `композиции` - объект создается внутри класса., это подвиды `Ассоциации`.

Собственно, в текущем ООП наследование нужно как раз для формирования иерархий знакомых объектов. И открыть ворота для
полиморфизма.

❗ Является причиной сильной привязки.

3. `Полиморфизм` – это переопределение поведения. Можно снова рассмотреть «человека» и «водителя», но теперь добавить
   «пешехода». Человек умеет как-то передвигаться, но как именно, зависит от того, водитель он или пешеход. То есть у
   пешехода и водителя схожее поведение, но реализованное по-разному: один перемещается ногами, другой – на машине.

❗ Является самое главное причиной использования ООП в практике (дает гибкость в статических языках).

Более подробно: https://github.com/VaLeraGav/hexlet-php/blob/master/src/Polymorphism/hexlet-theory.m

[//]: # (https://www.youtube.com/watch?v=ve3eAhuaF0s)

[//]: # (https://www.youtube.com/watch?v=bKbVmXuh9wQ)

[//]: # (https://www.youtube.com/watch?v=GA68iSWJ1lk)

[//Полиморфизм простыми словами]: # (https://medium.com/devschacht/polymorphism-207d9f9cd78)
Виды:

-
    1. `Ad-hoc` (Специальный) - в зависимости от типов аргументов применяется разная реализация какой-то операции.
       Перегрузка методов в статических языках (C++, С#).

```php
1 + 1; // 2
'cat' + 'dog'; // catdog
```

- `Параметрический` - Вызов ОДНОГО и того же кода для ВСЕХ допустимых типов (полиморфных) аргументов.

```php
$numbers1 = l(3, 4, 5, 8);
$strings1 = l('cat', 'dog');
```

-
    3. `Подтипов` (включения) - полиморфизм подтипов в объектно-ориентированных языках называют просто полиморфизм, что
       не
       совсем корректно. Вызов РАЗНОГО кода для РАЗНЫХ иерархий типов. (Он подразумевает ООР)

```php
 const obj = new SimpleCard(); // or PercentCard()
   obj.damage(health);
```

5. `Абстракция` говорит о том, что мы должны выделить важные характеристики объектов.
   Основной смысл этого заключается в зависимости от использования минимально необходимого набора характеристик для
   решения данной задачи.

6. `Отправка сообщений` - способ вызова процесса одного объекта, вызывающего метод другого объекта.

```php
$class = new A();
$class->metod();
```

Но на самом деле это
не так просто. Реализация ООП в Objective C отличается, потому что отправка сообщений немного отличается от C++, C# и
Java. Разница в том, что если у объекта нет вызываемого метода, то ничего не происходит. Например, с такой
реализацией
мы можем попытаться вызвать метод для нулевого объекта, не получая исключений.

[⏏ К содержанию](#содержание)

## Ошибки в ООП

[//]: # (https://www.youtube.com/watch?v=yNUJ3vAeyJQ)

Самые трудное понять `Инкопсуляцию`.

**Инкопсуляция** (почти правилно определение) механизм языка, позволяющий связывать
данные и методы, работающие с этими данными в единый объект.

Понятно, нет, не очень. Чтобы больше углубиться рассмотрим еще одно определение.

**Инкопсуляция** (второе почти правильное определение) - механизм языка, позволяющий ограничить доступ одних компонентов
программы к другим.

❗ Увидели, да, определения расходяться, в первом содержит назначение, а второе полезная фича. Второй вроде нормально, но
суть не раскрыли. Суть не раскрыта!

> **Инкапсуляция** (полное определение) - механизмязыка, позволяющий объединить данные и методы, работающие с этими
> данными в единый объект, и скрыть детали реализации от пользователя.

```php
// Данные связаные методом, првоявление Инкопсуляция
public function getDistance(Point $other){
    $dx = $this->x - $other->x;
    $dy = $this->y - $other->y;
    return Math::Sqrt($dx * $dx + $dy * $dy);
}
```

```php
// Данняе не связаные с функцией
public function getDistance($point1, $point2)
{
	$dx = $point1->x - $point2->x;
	$dx = $point1->y - $point2->y;

	return Math::Sqrt($dx * $dx + $dy * $dy);
}
```

[⏏ К содержанию](#содержание)

### Ковариантность, Контравариантность и Инвариантность

[//]: # (https://www.scorp13.com/workflow/princip-podstanovki-barbary-liskov-v-php.html)

`Ковариантность` позволяет дочернему методу возвращать более конкретный тип, чем тип возвращаемого значения его
родительского метода. В то время как `контравариантность` позволяет типу параметра в дочернем методе быть менее
специфичным, чем в родительском.


<details>
<summary>Пример Ковариантность, взят из документации</summary>

```php
// Ковариантность
abstract class Animal
{
    protected string $name;

    public function __construct(string $name)
    {
        $this->name = $name;
    }

    abstract public function speak();
}

class Dog extends Animal
{
    public function speak()
    {
        echo $this->name . " лает";
    }
}

class Cat extends Animal
{
    public function speak()
    {
        echo $this->name . " мяукает";
    }
}
/// Обратите внимание, что в примере нет методов, которые возвращают значения. Будет добавлено несколько фабрик, которые возвращают новый объект типа класса Animal, Cat или Dog.

interface AnimalShelter
{
    public function adopt(string $name): Animal;
}

class CatShelter implements AnimalShelter
{
    public function adopt(string $name): Cat // Возвращаем класс Cat вместо Animal
    {
        return new Cat($name);
    }
}

class DogShelter implements AnimalShelter
{
    public function adopt(string $name): Dog // Возвращаем класс Dog вместо Animal
    {
        return new Dog($name);
    }
}

$kitty = (new CatShelter)->adopt("Рыжик");
$kitty->speak(); // Рыжик мяукает
echo "\n";

$doggy = (new DogShelter)->adopt("Бобик");
$doggy->speak(); // Бобик лает

```
</details>

В продолжение предыдущего примера, где мы использовали классы Animal, Cat и Dog, мы введём новые классы Food и
AnimalFood и добавим в абстрактный класс Animal новый метод eat(AnimalFood $food).

<details>
<summary>Пример Контравариантность, взят из документации</summary>

```php
//Контравариантность
class Food {}

class AnimalFood extends Food {}

abstract class Animal
{
protected string $name;

    public function __construct(string $name)
    {
        $this->name = $name;
    }

    public function eat(AnimalFood $food)
    {
        echo $this->name . " ест " . get_class($food);
    }

}

// Чтобы увидеть суть контравариантности, мы переопределим метод eat класса Dog таким образом, чтобы он мог принимать
любой объект класса Food. Класс Cat оставим без изменений.

class Dog extends Animal
{
public function eat(Food $food) {
echo $this->name . " ест " . get_class($food);
}
}

// Следующий пример покажет поведение контравариантности.

$kitty = (new CatShelter)->adopt("Рыжик");
$catFood = new AnimalFood();
$kitty->eat($catFood); // Рыжик ест AnimalFood
echo "\n";

$doggy = (new DogShelter)->adopt("Бобик");
$banana = new Food();
$doggy->eat($banana); // Бобик ест Food

// Но что случится, если $kitty попробует съесть (eat) банан ($banana)?

$kitty->eat($banana);
// Fatal error: Uncaught TypeError: Argument 1 passed to Animal::eat() must be an instance of AnimalFood, instance of
Food given

```
</details>

Я хотел бы объяснить, почему важны ковариация и контравариантность и почему они применяются к типам возвращаемых
значений и типам параметров соответственно, а не наоборот.

`Ковариантность` - случай когда более конкретный тип S может быть подставлен вместо более обобщенного типа Т

`Контрвариантность` - случай когда более общий тип Т может быть подставлен вместо более конкретного типа S

`Инвариантность` - случай когда подставлять можно только определенный тип

Ковариацию, вероятно, легче всего понять, и она напрямую связана с принципом подстановки Лискова.

> Пусть Φ(x) является свойством, верным относительно объектов x некоторого типа T. Тогда Φ(y) также должно быть верным
> для объектов y типа S, где S является подтипом типа T.

**Итого**

- Тип возвращаемого значения можно сузить: подклассы могут возвращать подтипы типов, возвращаемых родительским классом
  или более узкие объединененные типы.
- Типы параметров метода могут быть расширены: подклассы должны принимать и обрабатывать все типы параметров, которые
  обрабатывает родительский метод. Но объединенный тип можно расширить таким образом, чтобы принимать больше типов или
  родительских типов.
- Типы свойств не могут быть изменены.

```php
class Name {
    protected XXX $foo; // XXX - не изменяеться 
    
    public function yyy(XXX mmm1): mmm2 {
                // XXX - можно расширить 
                // mmm2 - можжно сузить
    }
}
```

[⏏ К содержанию](#содержание)