<!-- https://github.com/index0h/php-conventions#53-solid -->

# Чистый код

> «Я тебя насквозь вижу. Ты опять не следуешь принципам чистого кода?» — Роберт Мартин

## Содержание

---

1. [Вступление](#вступление)
1. [Правила оформления кода](#1-правила-оформления-кода)
2. [Документирование](#2-документирование)
3. [Объявление констант, свойств и методов](#3-объявление-констант-свойств-и-методов)
4. [Безопасность](#4-безопасность)
5. [Принципы программирования](#5-принципы-программирования)
6. [Тестирование](#6-тестирование)
7. [Чистый код, кратко из книги и статей](#чистый-код-кратко-из-книги-и-статей)
8. [Основные принципы структурирования кода](#основные-принципы-структурирования-кода)

---

## Вступление

### Что значит (P)A/HC/LC?

```
префикс? (P) + действие (A) + высокоуровневый контекст (HC) + низкоуровневый контекст? (LC)
```

### Что обозначает префикс (P)?

- `is` - описывает свойство или состояние текущего контекста (обычно — логическое значение)

```php
$color = 'blue';
$isBlue = ($color === 'blue'); // свойство
$isPresent = true; // состояние
```

- `has` - указывает имеет ли текущий контекст определенное значение или состояние
- `should` - Отражает положительный условный оператор, свящанным с определенным действием

 ```php
$shouldUpdateUrl = fn ($url, $expectedUrl) => $url !== $expectedUrl;
 ```

### (Action) Действие — это сердце функции

- `get` - Получает доступ к данным немедленно (сокращение от getter для внутренних данных).
- `set` - Безусловно присваивает переменной со значением A значение B.
- `reset` - Возвращает переменную к её начальному значению или состоянию.
- `fetch` - Выполняет запрос данных, для которого требуется время (например, асинхронный запрос).

 ```php
$fetchPosts = fn($postCount) => fetch('https://api.dev/posts');
 ```

- `remove` -Удаляет что-то откуда-то.
- `delete` - Полностью стирает что-то. После операции сущность перестаёт существовать.
- `compose` - Создает новые данные из существующих

```php
$composePageUrl = fn($pageName, $pageId) => "{$pageName}-{$pageId}";

```

- `handle` - Обработка действия. Часто используется при именовании обратного вызова.

```js
const handleLinkClick = () => {
    console.log('Clicked a link!');
};

link.addEventListener('click', handleLinkClick);
```

### (HC/LC) - контекст

**Контекст** — это область, с которой работает функция.

**Функция** — это часто действие с чем-то. Важно указать, какова её рабочая область или, по крайней мере, ожидаемый тип
данных.

```js
/* Чистая функция, работающая с примитивами */
const filter = (list, predicate) => list.filter(predicate);

/* Функция, работающая непосредственно с сообщениями */
const getRecentPosts = (posts) => filter(posts, (post) => post.date === Date.now());

/*
Некоторые специфические для языка допущения позволяют опустить контекст.
Например, в JavaScript фильтр обычно работает с массивом (Array).
Добавление явного filterArray будет избыточным.
*/
```

Иногда встречаются подобные варианты: diffBuild, но правильно писать наоборот: buildDiff. Сначала `«что делаем?»` (какое
действие), затем `«над чем?»` (предмет, на который направлено действие).

Чтобы создать пару переменных, можно использовать антонимы: oldValue, newValue.

- min/max
- up/down
- begin/end
- finish/start
- next/previous
- create/destroy
- increase/decrease
- show/hide

## Состояния

- new ( новый )
- ready ( в состояние готовности )
- waiting ( в ожидании )
- executing ( исполнение )
- blocked ( заблокирован, ожидает чего-либо )
- suspend ( приостановить )
- terminated ( завершенный )

## Венгерская нотация (HN)

Прежде всего, существует множество различных метаданных, которые вы можете добавить к именам идентификаторов, и все они
принадлежат к разным категориям. Вот категории, которые я определил на данный момент (их может быть больше):

- Информация о типе.
- Информация о видимости.
- Семантическая информация.

[Полное соглашение о стиле кода](https://learn.microsoft.com/ru-ru/windows/win32/stg/coding-style-conventions)

| Prefix | Описание                                  |
|--------|-------------------------------------------|
| а	     | Array                                     |
| b	     | Bool (int)                                |
| с	     | Char                                      |
| s	     | Строка                                    |
| i	     | Целочисленный тип                         |
| u	     | Целое число без знака                     |
| n	     | Краткое целое число (целое)               |
| d      | Double                                    |
| x,y	   | Координаты x, y (короткие)                |
| f	     | Флаги (обычно несколько битовых значений) |
| fn	    | Функция                                   |
| g_	    | Глобальный                                |
| h	     | Дескриптор                                |
| _	     | Защищенный тип                            |
| m_	    | Член данных класса                        |
| p	     | Указатель                                 |

--- 

[⏏ К содержанию](#содержание)

## 1. Правила оформления кода

### 1.1. Базовый стандарт оформления кода

Код ДОЛЖЕН быть оформлен согласно всем правилам, указанным в стандарте [PSR-12](https://www.php-fig.org/psr/psr-12/).

### 1.2. Строки

Жесткое ограничение строки ДОЛЖНО составлять 120 символов. В случае превышения этого ограничения автоматические системы
проверки стиля ДОЛЖНЫ считать это ошибочной ситуацией, для таких ситуаций НЕОБХОДИМО явно отключать проверку стиля с
помощью аннотаций:

```php
use VendorWithVerlyLongName\ProjectrWithVerlyLongName\ServicesWithVerlyLongName\ServiceFolderWithVerlyLongName\ClassWithVerlyLongName;
```

### 1.3. Массивы

При объявлении многострочного массива в конце последнего объявления ДОЛЖНА ставиться запятая, для однострочного массива
запятую ставить НЕДОПУСТИМО.

```php
// Правильно
[
    'firstElement'  => 'firstElement',
    'secondElement' => 'secondElement',
]
```

```php
// Неправильно
[
    'firstElement'  => 'firstElement',
    'secondElement' => 'secondElement'
]
```

```php
// Правильно
['firstElement' => 'firstElement', 'secondElement' => 'secondElement']
```

```php
// Неправильно
['firstElement' => 'firstElement', 'secondElement' => 'secondElement',]
```

### 1.4. Выделение управляющих инструкций

Управляющие инструкции: if, for, foreach, while, do-while, switch, break, continue, return ДОЛЖНЫ отделяться от кода
того же уровня вложенности одной пустой строкой.

```php
// Правильно
$count = 5;

if ($count === 5) {
// ...
}

// ...
```

```php
// Неправильно
$count = 5; // Отсутствует перевод строки
if ($count === 5) {
// ...
}
$length = 12; // Отсутствует перевод строки
// ...
```

### 1.5. Скобки

Круглые скобки:

- Внутри не разделяются пробелом.
- Снаружи разделяются пробелами управляющие конструкции
- После названия метода/функции — пробел не ставится.

Перед возвращаемым значением(return) обязательно ставится перенос строки, если метод не состоит из единственной строки.

```php
function segmentToString($segment)
{
    if (empty($segment)) {
        return null;
    }
    
    $start = pointToString(startSegment($segment));
    $end = pointToString(endSegment($segment));

    return "[$start, $end]";
}
```

Содержимое класса разделяется сверху одной пустой строкой.

```php
class InterfaceType {

    private $property = 'myProp';

    public function getProperty():string {
        return $this->property;
    }    
}
```

[⏏ К содержанию](#содержание)

## 2. Документирование

За любой закрывающей фигурной скобкой НЕ ДОЛЖЕН следовать какой-либо комментарий или утверждение в той же строке.

### 2.1. Базовый стандарт для оформления документации в коде

Код ДОЛЖЕН быть оформлен согласно правилам, указанным в стандарте PSR-19.
Указание типов аргументов с помощью `@param` и `@return`, дублирующее сигнатуру метода НЕДОПУСТИМО, кроме случаев:

- Наличия комментария к параметру, или результату.
- Аннотации используются сторонними средствами: psalm, phan, phpstan, и т.д.

```php
// Правильно
public function incrementProductPriceByName(string $productName, float $price): bool
{
// ...
```

```php
// Неправильно
/**
 * @param string $productName
 * @param float  $price
 * @return bool
 */
public function incrementProductPriceByName(string $productName, float $price): bool
{
// ...
```

```php
// Правильно
/** 
 * @param array $parsedUrl
 * @phan-param array{scheme:string,host:string,path:string} $parsedUrl
 * @psalm-param array{scheme:string,host:string,path:string} $parsedUrl  
*/
public function showUrl(string $label, array $parsedUrl, string $host): string
{
```

Указание типов свойств с помощью `@var`, дублирующее тип свойства НЕДОПУСТИМО, кроме случаев наличия комментария к
свойству (php 7.4+).

```php
// Правильно (< php 7.4)
/** @var string */
private $productName;
```

```php
// Неправильно (< php 7.4)
private $productName;
```

```php
// Правильно (php 7.4+)
private ?string $productName;
```

```php
// Правильно (php 7.4+)
/** @var string|null Contains product name */
private ?string $productName;
```

```php
// Неправильно (php 7.4+)
/** @var string|null */
private ?string $productName;
```

### 2.3. Массивы в docblock

Типы элементов массивов РЕКОМЕНДУЕТСЯ уточнять в docblock.

```php
// Правильно
/**
 * @param string[] $productNames
 */
public function incrementProductPricesByNames(array $productNames, float $price): bool
{
// ...
```

```php
// Неправильно
/**
 * @param array $productNames
 */
public function incrementProductPricesByNames(array $productNames, float $price): bool
{
// ...
```

### 2.4. Неопределенные типы аргументов и возвращаемых результатов

В случае, если аргумент (или возвращаемый результат) метода может быть разных типов НЕОБХОДИМО перечислить все
допустимые типы в docblock.

```php
// Правильно
/**
 * @param string|int $stringOrIntArgument
 * @return float|string|object
 */
public function mixedMethod($stringOrIntArgument)
{
// ...
```

```php
// Неправильно
/**
 * @param mixed $stringOrIntArgument
 * @return mixed
 */
public function mixedMethod($stringOrIntArgument)
{
// ...
```

### 2.5. Тип переменных

Если ожидаемый тип переменной явно не определен НЕОБХОДИМО определить его с помощью однострочного docblock комментария.
Так же необходимо указывать ожидаемый тип, если IDE не может его определить, или определяет не корректно.

```php
$rows = [
    [
        'id'        => 1,
        'createdAt' => new \DateTimeImmutable(),
    ],
    [
        'id'        => 2,
        'createdAt' => new \DateTimeImmutable(),
    ],
    // ...
];
foreach ($rows as $row) {
    /** @var int $id */
    $id = $row['id'];
    /** @var \DateTimeImmutable $createdAt */
    $createdAt = $row['createdAt'];
    // ...
}
```

### 2.6. Методы и функции

- Docblock для методов и функций ДОЛЖНЫ быть многострочными.
- Название метода должно передавать намерения программиста
- Название метода должно сообщить, почему этот метод существует, что он
  делает и как используется (isPostRequest, getRequestType, parseSchemaElement, renderPageWithSetupsAndTeardowns)
- Название метода должно начинаться с глагола
- Названия boolean методов должны содержать глагол is, has или can
- Имена методов НЕ ДОЛЖНЫ иметь префикс с одним подчеркиванием ( _metodName ) для обозначения защищенной или частной
  видимости. То есть префикс подчеркивания явно не имеет значения.

```php
// Неправильно
/** @param string[] $userNames */
public function saveUserNames(array $userNames): void
```

```php
// Правильно
/**
 * @param string[] $userNames
 */
public function saveUserNames(array $userNames): void
```

[⏏ К содержанию](#содержание)

## 3. Объявление констант, свойств и методов

### 3.1. Последовательность объявлений констант, свойств и методов

В классе ДОЛЖНА соблюдаться последовательность объявлений элементов согласно следующему списку:

1. Публичные константы.
2. Защищенные константы.
3. Приватные константы.
4. Публичные свойства.
5. Защищенные свойства.
6. Приватные свойства.
7. __construct.
8. __destruct.
9. __clone.
10. __invoke.
11. __toString.
12. Публичные методы.
13. Защищенные методы.
14. Приватные методы.

### 3.2. Модификаторы доступа для свойств

Для модификаторов доступа к свойствам ДОЛЖНЫ выполняться следующие правила:

- `private` - СЛЕДУЕТ использовать по умолчанию;
- `protected` - СЛЕДУЕТ использоваться только для случаев доступа из дочерних классов;
- `public` - использование НЕДОПУСТИМО;
- `static` - использование НЕДОПУСТИМО.

### 3.3. Модификаторы доступа для методов

Для модификаторов доступа к свойствам ДОЛЖНЫ выполняться следующие правила:

- `private` - СЛЕДУЕТ использовать для методов, предназначенных для использования внутри класса;
- `protected` - СЛЕДУЕТ использоваться только для случаев доступа из дочерних классов;
- `public` - СЛЕДУЕТ использовать для методов, которые предназначены для использования из вне;
- `static` - использование НЕДОПУСТИМО.

### 3.4. Порядок аргументов в методе

Аргументы метода ДОЛЖНЫ объявляться в следующей последовательности:

1. Типизированные аргументы.
2. Nullable-аргументы.
3. Опциональные аргументы.
4. Аргумент с `...`. (php 7.4+)

```php
public function firstExample(string $first, ?int $second, bool $third = false, float ...$fourth): string 
{
    // ...
}

public function secondExample(?int $second, bool $third = false, float ...$fourth): string
{
    // ...
}

public function thirdExample(bool $third = false, float ...$fourth): string
{
    // ...
}
```

[⏏ К содержанию](#содержание)

## 4. Безопасность

### 4.1. Неявные приведения типов

Неявное приведение типов НЕДОПУСТИМО.

> Неявное приведение типов — один из наиболее распространенных источников ошибок.
> Проблемы, возникающие при неявном приведении типов сложно отслеживать,
> так же они могут приводить к непредсказуемым последствиям.

```php
// неправильно
echo 5 + '5abc5';
// 10
```

### 4.2. Сравнения с преобразованием типов

Сравнения с преобразованием типов `==` и `!=` НЕДОПУСТИМЫ.
Вместо этого НЕОБХОДИМО использовать тождественные сравнения: `===` и `!==`.

> Проблемы тут те же, что и при неявном приведении типов.

```php
// неправильно
if ('abc' == 0) {
    echo 'wat';
}
// wat
```

### 4.3. Инструкция switch

Использовать инструкцию `switch` НЕОБХОДИМО с гарантией корректности типов каждого проверяемого выражения.

> Инструкция `switch` при выполнении проверок `case` использует сравнения с приведением типов.
> Это может привести к тем же проблемам, что и неявное приведение типов.

```php
// неправильно
switch ('abc') {
    case 0:
        echo 'wat';
        break;
}
// wat
```

### 4.4. Присвоения в условных операциях

Присвоение в условиях инструкций `if`, `while`, `do-while` НЕДОПУСТИМО.

> В большом количестве учебной литературы используются конструкции вида `while ($row = ...)` или `if ($row = ...)`.
> Выражения в скобках неявно приводятся к `bool`, что может привести к неожиданным последствиям.

```php
// неправильно
$rows = [0, null, ''];
while ($row = next($rows)) {
    printf("\$row = %s\n", var_dump($row, true));
}
// Ничего не выведет
```

### 4.5. Ошибки

Создание ошибок с помощью `trigger_error` НЕДОПУСТИМО, вместо этого ДОЛЖНЫ использоваться исключения.

> Ошибки могут быть перехвачены только глобально, с помощью `set_error_handler`.
> Это значит, что контекст выполнения будет потерян.
> Так же ошибки не содержат stack trace, в отличие от исключений.

### 4.6. Оператор управления ошибками @

Оператор `@` ДОЛЖЕН быть использован для выражений, которые могут бросить ошибку,
для остальных ситуаций его использование НЕДОПУСТИМО.
В случае подавления ошибки ДОЛЖНО быть брошено исключение с описанием причин возникновения ошибки.

```php
// Без @ будет ошибка:
// Warning: fopen(path/to/not/exists/file): failed to open stream: No such file or directory
$file = @fopen('path/to/not/exists/file', 'r');
if ($file === false) {
    throw new \RuntimeException('Could not open file: "path/to/not/exists/file"');
}
```

### 4.7. goto

Использование инструкции `goto` НЕДОПУСТИМО.

> Оператор `goto` используется для перехода в другую часть программы, чем усложняет чтение и понимание кода.

### 4.8. eval

Использование инструкции `eval` НЕДОПУСТИМО.

> Для безопасного выполнения `eval` необходимо выполнить очень детальный анализ кода, который будет выполняться.
> Сложность требуемых проверок растет экспоненциально с операциями, ожидаемыми для выполнения в `eval`.

### 4.9. Глобальные переменные и global

Использование инструкции `global` НЕДОПУСТИМО.

> Глобальные переменные являются неявными аргументами функции, или метода, не гарантирующими ни тип, ни значение,
> ни даже своего существования.

### 4.10. Статические свойства

Использование статических свойств НЕДОПУСТИМО (используются в методах).

> Статические свойства, по аналогии с глобальными переменным являются неявными аргументами функции, или метода, не
> гарантирующими ни тип, ни корректного состояния.

### 4.11. Суперглобальные переменные

Использование суперглобальных переменных ДОЛЖНО быть сведено к минимуму.
Данные из суперглобальных переменных РЕКОМЕНДУЕТСЯ получать на этапе инициализации.

### 4.12. Динамическая подстановка имен

Динамическая подстановка имен переменных, свойств, функций и методов НЕДОПУСТИМА.

> Динамическая подстановка имен сильно усложняет чтение и отладку кода потому, что конечные имена определяются только
> в рантайме.

```php
// Неправильно
$this->{$methodName}($argument);
```

### 4.13. Магические методы

Использование следующих магических методов НЕДОПУСТИМО:

* `__call`
* `__callStatic`
* `__get`
* `__set`

> Данные методы усложняют чтение и понимание кода, как следствие его поддержку.

### 4.14. Валидация аргументов

Каждый аргумент публичного метода, защищенного метода, или функции ДОЛЖЕН быть проверен на корректность типа и граничные
значения.
Каждый аргумент приватного метода ДОЛЖЕН быть проверен на корректность типа, проверять граничные значения РЕКОМЕНДУЕТСЯ.
Если аргумент не валиден — штатное выполнение метода (функции) невозможно, по этой причине ДОЛЖНО быть брошено
исключение.

### 4.15. \DateTime

Вместо `\DateTime` НЕОБХОДИМО использовать `\DateTimeImmutable`.

> Так как в PHP объекты передаются по ссылке изменение объекта `\DateTime` в одной части кода влечет за собой изменение
> по всему рантайму, что может привести к непредсказуемым последствиям. Что бы исключить целый класс ошибок, связанных
> с не явным изменением даты/времени из внешнего кода НЕОБХОДИМО использовать `\DateTimeImmutable`.

```php
$externalServiceGenerateExpiredAt = function (\DateTime $createdAt): \DateTime {
    return $createdAt->modify('3 days');
};
$createdAt = new \DateTime('2019-01-01');
$expiredAt = $externalServiceGenerateExpiredAt($createdAt);
printf("createdAt: %s, expiredAt: %s", $createdAt->format('Y-m-d'), $expiredAt->format('Y-m-d'));
// createdAt: 2019-01-04, expiredAt: 2019-01-04
```

### 4.16. Обработка часовых поясов

Для задач хранения и обработки времени НЕОБХОДИМО использовать часовой пояс `UTC`.
Для задач связанных с выводом МОЖНО использовать произвольный часовой пояс.

> В случае хранения или обработки времени со смещением по часовому поясу есть большая вероятность возникновения ошибок
> связанных с несоответствием часовых поясов.

### 4.17. SQL

Для подстановки параметров в SQL запросы НЕОБХОДИМО использовать
[псевдопеременные](https://www.php.net/manual/ru/pdo.prepared-statements.php).

> Подстановка параметров с помощью конкатенации ведет к целому классу проблем безопасности: sql-инъекции.

```php
$stmt = $dbh->prepare("INSERT INTO REGISTRY (name, value) VALUES (:name, :value)");
$stmt->bindParam(':name', $name);
$stmt->bindParam(':value', $value);

stmt = $dbh->prepare("INSERT INTO REGISTRY (name, value) VALUES (?, ?)");
$stmt->bindParam(1, $name);
$stmt->bindParam(2, $value);
```

[⏏ К содержанию](#содержание)

## 5. Принципы программирования

### 5.1. Здравый Смысл

Принцип Здравого Смысла разрешает отмену любого правила данных рекомендаций, в случае, когда правило приводит к
чрезмерному усложнению поддержки кода.
Этот принцип МОЖНО использовать, но очень осторожно.

### 5.2. YAGNI

РЕКОМЕНДУЕТСЯ следовать принципу [YAGNI](https://ru.wikipedia.org/wiki/YAGNI).

`«Вам это не понадобится»` - процесс и принцип проектирования ПО, при котором в качестве основной цели и/или ценности
декларируется отказ от избыточной функциональности, — то есть отказ добавления функциональности, в которой нет
непосредственной надобности.

### 5.3. SOLID

Код ДОЛЖЕН следовать принципам [SOLID](https://ru.wikipedia.org/wiki/SOLID_(объектно-ориентированное_программирование)).

- `Принцип единственной ответственности` (single responsibility principle)
  Для каждого класса должно быть определено единственное назначение. Все ресурсы, необходимые для его осуществления,
  должны быть инкапсулированы в этот класс и подчинены только этой задаче.

- `Принцип открытости/закрытости` (open-closed principle)
  «программные сущности … должны быть открыты для расширения, но закрыты для модификации».

- `Принцип подстановки Лисков` (Liskov substitution principle)
  «функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа не зная об
  этом». См. также контрактное программирование.

- `Принцип разделения интерфейса` (interface segregation principle)
  «много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс общего назначения».

- `Принцип инверсии зависимостей` (dependency inversion principle)
  «Зависимость на Абстракциях. Нет зависимости на что-то конкретное».

### 5.4. DRY

Принципу [DRY](https://ru.wikipedia.org/wiki/Don't_repeat_yourself) СЛЕДУЕТ придерживаться только в случае, когда он не
противоречит SOLID и Здравому смыслу.

`«не повторяйся»` — это принцип разработки программного обеспечения, нацеленный на снижение повторения информации
различного рода, особенно в системах со множеством слоёв абстрагирования.

Примеры, когда не стоит следовать принципу DRY:

* У вас есть две разных сущности, отвечающие разным доменам с некой общей функциональностью.
    - В такой ситуации не стоит наследовать сущности одну от другой, или общую функциональность выносить в абстрактный
      класс, или трейт. Дело в том, что общая функциональность является общей только в текущий момент времени, в будущем
      же она может измениться в каждом домене по своему. Фактически вам придется в общей функциональности реализовывать
      ее разделение, в зависимости от домена.

* В тестах DRY может привести к ложно позитивным и ложно негативным ошибкам.

### 5.5. KISS

Принципу [KISS](https://ru.wikipedia.org/wiki/KISS_(принцип)) СЛЕДУЕТ придерживаться только в случае, когда он не
противоречит другим правилам данных рекомендаций.

`«Делай проще, тупица»` - утверждает, что большинство систем работают лучше всего, если они остаются простыми, а не
усложняются

Примеры, когда не стоит следовать принципу KISS:

* Класс должен быть "не большого размера". Если придерживаться этого правила - в результате у вы усложните
  взаимодействие между вашими объектами, что может привести к существенному увеличению сложности в поддержке кода. По
  этой причине класс должен полностью описывать объект реального мира, которому он соответствует.

* Методы должны быть "не большого размера". Здесь проблемы те же, что и у классов. Разделяя метод на множество маленьких
  вы расширяете интерфейс класса, что в будущем может привести к излишней связанности, как с данным классом, так и с его
  наследниками.

### 5.6. TMTOWTDI

Принцип [TMTOWTDI](https://ru.wikipedia.org/wiki/TMTOWTDI) НЕ РЕКОМЕНДУЕТСЯ использовать.

`«Тим Тоуди»`, или `«There’s More Than One Way To Do It»` («Есть больше одного способа сделать это») — девиз языка Perl.
В соответствии с этой идеей синтаксис языка предоставляет программисту множество возможностей для записи одного и того
же алгоритма, позволяя выбирать ту из них, которая кажется наиболее удобной и эффективной в данном конкретном случае.

- Множество способов реализации одного и того же алгоритма ведет к тому, что правки алгоритма придется выполнять в
  каждой реализации, что в свою очередь усложняет поддержку и увеличивает вероятность ошибок.

### 5.7. GRASP

РЕКОМЕНДУЕТСЯ следовать принципам [GRASP](https://ru.wikipedia.org/wiki/GRASP).

`«контроль, хватка»` — шаблоны, используемые в объектно-ориентированном проектировании для решения общих задач по
назначению ответственностей классам и объектам.

- `Информационный эксперт (Information Expert)`

Ответственность должна быть назначена тому, кто владеет максимумом необходимой информации для исполнения —
информационному эксперту.

- `Создатель (Creator)`

Creator или Создатель — суть ответственности такого объекта в том, что он создает другие объекты. Сразу напрашивается
аналогия с абстрактной фабрикой. По сути шаблон проектирования Абстрактная фабрика (создание объектов концентрируется в
отдельном классе) это альтернатива создателя.

- `Контроллер (Controller)`

Шаблон сontroller призван решить проблему разделения интерфейса и логики в интерактивном приложении. Это не что иное,
как хорошо известный контроллер из MVC парадигмы.

- `Слабое зацепление (Low Coupling)`

Если объекты в приложении сильно связанны, то любой их изменение приводит к изменениям во всех связанных объектах. А это
неудобно и порождает множество проблем. Low coupling как раз говорит о том что необходимо, чтобы код был слабо связан и
зависел только от абстракций. Слабая связанность так же встречается в SOLID принципах как The Dependency Inversion
Principle (DIP) и слабая связанность по сути это реализация Dependency Injection принципа.

- `Высокая связность (High Cohesion)`

По сути High Cohesion очень тесно связанна с Single Responsibility Principle (SRP) сSOLID принципов. High Cohesion
получается в результате соблюдения SRP.

- `Полиморфизм (Polymorphism)`

Полиморфизм позволяет реализовывать одноименные публичные методы, позволяя различным классам выполнять различные
действия при одном и том же вызове. То есть объекты классов Square и Circle могут отображаться(реализовывать метод
render) по разному несмотря не то, что они оба подклассы Shape, метод render определен в Shape. (Overriding).

- `Чистая выдумка (Pure Fabrication)`

Pure Fabrication или чистая выдумка, или чистое синтезирование. Здесь суть в выдуманном объекте. Аналогом может быть
шаблон Service (сервис) в парадигме DDD.

- `Посредник (Indirection)`

Indirection или посредник. Можно столкнуться с таким вопросом: «Как определить ответственность объекта и избежать
сильной связанности между объектами, даже если один класс нуждается в функционале (сервисах), который предоставляет
другой класс?»

Решение: возложите ответственность на промежуточный объект, чтобы он осуществлял связь между другими компонентами или
службами, чтобы они не были напрямую связаны. Такое решение можно сделать с помощью GoF паттерна медиатор.

- `Устойчивость к изменению (Protected Variations)`

Проблема: Как спроектировать объекты, подсистемы и системы таким образом, чтобы изменения или нестабильность этих
элементов не оказывали нежелательного влияния на другие элементы?
Решение: Определите точки прогнозируемого изменения или нестабильности, распределите обязанности по созданию стабильного
интерфейса вокруг них.

[⏏ К содержанию](#содержание)

## 6. Тестирование

[-> Чистый PHPUnit](https://github.com/VaLeraGav/Notes/blob/main/Clean%20PHPUnit.md)

### 6.1. Покрытие кода

Каждый метод (функция) ДОЛЖНЫ быть покрыты тестами для всех возможных вариантов выполнения метода (функции).

Каждый тест ТРЕБУЕТСЯ оформлять согласно структуре, описанной ниже (каждый блок отделяется от остальных пустой строкой).

1. Ожидаемый тип исключения.
2. Ожидаемое сообщение исключения.
3. Переменные, используемые в тесте.
4. Mock-объекты аргументов конструктора тестируемого класса.
5. Mock-объекты аргументов тестируемого метода.
6. Создание тестируемого объекта.
7. Инкременты вызовов mock-объектов.
8. Поведение методов mock-объектов согласно порядку их вызова.
9. Вызов тестируемого метода.
10. Проверка результатов.

ДОПУСКАЕТСЯ отклонение от данной структуры, в случае, если полное следование ей невозможно. Например, когда значение
переменной [3] определяется только после вызова конструктора тестируемого класса [6].

Характеристики хорошего и удобочитаемого теста:

1. Содержит только необходимые вызовы метода assert (желательно один).
2. Он очень понятно объясняет, что должно произойти при заданных условиях.
3. Он тестирует только одну ветку исполнения метода.
4. Он не делает заглушку для целой вселенной ради какого-то утверждения.

```php


// Для данного метода ДОЛЖНО быть 3 теста.
// 1. Число $number кратно $divider, что бы проверить корректность преобразование типа.
// Например `divide(4, 2);`.
// 2. Число $number не кратно $divider. Например `divide(1, 2);`.
// 3. Число $divider равно 0. Например `divide(3, 0);`.
public function divide(int $number, int $divider): float.
{
    if ($divider === 0) {
        throw new \InvalidArgumentException('Argument "$divider" must be not zero');
    }

    return (float) $number / $divider;
}

// Для данного метода ДОЛЖНО быть 4 теста.
// 1. Название команды соответствует `self::FIRST_COMMAND`.
// 2. Название команды соответствует `self::SECOND_COMMAND`.
// 3. Название команды - пустая строка.
// 4. Команда не найдена.
public function execute(string $commandName): void
{
    if (empty($commandName)) {
        throw new \InvalidArgumentException('Argument "$commandName" must be not empty');
    }

    switch ($commandName) {
        case self::FIRST_COMMAND:
            $this->firstCommand();

            break;
        case self::SECOND_COMMAND:
            $this->secondCommand();

            break;
        default:
            throw new \DomainException(sprintf('Unknown command: "%s"', $commandName));
    }
}
```

[⏏ К содержанию](#содержание)

## Чистый код, кратко из книги и статей

Возможно что-то будет повторяться с информацией написаной свеху.

[//Спасибо автору поста]: # (https://habr.com/ru/post/485118/)

[//Спасибо помог разобраться]: # (https://github.com/beardlessman/books)

### **Глава 1. Чистый код**

Что же такое этот самый чистый код по версии Мартина в нескольких словах? Это код без дублирования, с минимальным
количеством сущностей, удобный для чтения, простой. В качестве девиза можно было бы выбрать: «Ясность превыше всего!».

### Глава 2. Содержательные имена

1. `Имена должны передавать намерения программиста`

Имя переменной, функции или класса должно сообщить, почему эта переменная существует, что она делает и как
используется. Если имя требует дополнительных комментариев, значит, оно не передает намерений программиста. Лучше
написать, что именно измеряется и в каких именно единицах.

2. `Избегайте дезинформации `

Не используйте слова со скрытыми значениями, отличными от предполагаемого. Остерегайтесь малозаметных различий в
именах. Например, XYZControllerForEfficientHandlingOfStrings и XYZControllerForEfficientStorageOfStrings.

3. `Используйте осмысленные различия `

Если имена различаются, то они должны обозначать разные понятия.

«Числовые ряды» вида (a1, a2,… aN) являются противоположностью сознательного присваивания имен. Они не несут
информации и не дают представления о намерениях автора.

Неинформативные слова избыточны. Слово variable никогда не должно встречаться в именах переменных. Слово table
никогда не должно встречаться в именах таблиц. Чем имя NameString лучше Name? Разве имя может быть, скажем,
вещественным числом?

Используйте удобопроизносимые имена: generationTimestamp намного лучше genymdhms.

4. `Используте удобопроизносимые имена`

Код читают. О коде разговаривают. Имена должны нормально произноситься вслух. Избегать дурацких сокращений, непонятных
аббревиатур и кодов.

В другой книжке есть яркий пример, который живет и процветает – аббревиатура SQL. Принятое на Западе произношение:
«сиквел»; у нас же я слышал только «эскюэль».

5. `Выбирайте имена, удобные для поиска `

Однобуквенные имена могут использоваться только для локальных переменных в коротких методах.

6. `Избегайте схем кодирования имен `

Как правило, кодированные имена плохо произносятся и в них легко сделать опечатку.

7. `Интерфейсы и реализации`

Я (автор книги) предпочитаю оставлять имена интерфейсов без префиксов. Префикс I, столь распространенный в старом коде,
в лучшем случае отвлекает, а в худшем — передает лишнюю информацию. Я не собираюсь сообщать своим
пользователям, что они имеют дело с интерфейсом.

8. `Имена классов`

Имена классов и объектов должны представлять собой существительные и их комбинации: Customer, WikiPage, Account и
AddressParser. Старайтесь не использовать в именах классов такие слова, как Manager, Processor, Data или Info. Имя
класса не должно быть глаголом.

9. `Имена методов`

Имена методов представляют собой глаголы или глагольные словосочетания: postPayment, deletePage, save и т. д.
Методы чтения/записи и предикаты образуются из значения и префикса get, set и is согласно стандарту javabean.

9. `Воздержитесь от каламбуров`

Задача автора — сделать свой код как можно более понятным. Код должен восприниматься с первого взгляда, не требуя
тщательного изучения. Ориентируйтесь на модель популярной литературы, в которой сам автор должен доступно выразить
свои мысли.

10. `Добавьте содержательный контекст`

Контекст можно добавить при помощи префиксов: addrFirstName, addrLastName, addrState и т. д. По крайней мере
читатель кода поймет, что переменные являются частью более крупной структуры. Конечно, правильнее было бы создать
класс с именем Address, чтобы даже компилятор знал, что переменные являются частью чегото большего.

11. `Не добавляйте избыточный контекст`

Короткие имена обычно лучше длинных, если только их смысл понятен читателю кода. Не включайте в имя больше
контекста, чем необходимо.

Будет мешать автокомплиту + в принципе засоряет код, лишние префиксы все равно взглядом будут игнорироваться.

### Глава 3. Функции

1. `Компактность! `

Первое правило: функции должны быть компактными.

Второе правило: функции должны быть еще компактнее.

Мой практический опыт научил меня (ценой многих проб и ошибок), что функции должны быть очень маленькими. Желательно,
чтобы длина функции не превышала 20 строк.

2. `Правило одной операции`

Функция должна выполнять только одну операцию. Она должна выполнять ее хорошо. И ничего другого она делать не
должна. Если функция выполняет только те действия, которые находятся на одном уровне под объявленным именем
функции, то эта функция выполняет одну операцию.

3. `Секции в функциях`

Функцию, выполняющую только одну операцию, невозможно осмысленно разделить на секции.

4. `Один уровень абстракции на функцию`

Чтобы убедиться в том, что функция выполняет «только одну операцию», необходимо проверить, что все команды функции
находятся на одном уровне абстракции.

Смешение уровней абстракции внутри функции всегда создает путаницу.

5. `Чтение кода сверху вниз: правило понижения`

Код должен читаться как рассказ — сверху вниз.

За каждой функцией должны следовать функции следующего уровня абстракции. Это позволяет читать код,
последовательно спускаясь по уровням абстракции в ходе чтения списка функций. Я называю такой подход «правилом
понижения».

ТО-абзац – дефиниция. Например: renderPageWithSettings – функция, генерирующая код страницы в соответствии с переданными
параметрами.

6. `Команды switch`

Написать компактную команду switch довольно сложно. Даже команда switch всего с двумя условиями занимает больше
места, чем в моем представлении должен занимать один блок или функция. Также трудно создать команду switch,
которая делает что-то одно — по своей природе команды switch всегда выполняют N операций. К сожалению, обойтись
без команд switch удается не всегда, но по крайней мере мы можем позаботиться о том, чтобы эти команды были скрыты
в низкоуровневом классе и не дублировались в коде. И конечно, в этом нам может помочь полиморфизм.

В примере представлена всего одна операция, зависящая от типа работника.

    ```php
    public MoneycalculatePay(Employee e)
      throws InvalidEmployeeType {
          switch (e.type) {
              case COMMISSIONED:
                  return calculateCommissionedPay(e);
              case HOURLY:
                  return calculateHourlyPay(e);
              case SALARIED:
                  return calculateSalariedPay(e);
              default:
                  thrownew InvalidEmployeeType(e.type);
          }
      }
    ```

Эта функция имеет ряд недостатков.
Во-первых, она велика, а при добавлении новых типов работников она будет
разрастаться.

Во-вторых, она совершенно очевидно выполняет более одной операции.

В-третьих, она нарушает принцип
единой ответственности (Single responsibility principle), так как у нее существует несколько возможных причин
изменения.

В-четвертых, она нарушает принцип открытости/закрытости (The Open Closed Principle), потому что код функции должен
изменяться при каждом добавлении новых типов.

Но, пожалуй, самый серьезный недостаток заключается в том, что программа может содержать неограниченное количество
других функций с аналогичной структурой, например: isPayday(Employee e, Date date) или deliverPay(Employee e,
Money pay) и так далее. Все эти функции будут иметь все ту же ущербную структуру. Решение проблемы заключается в
том, чтобы похоронить команду switch в фундаменте абстрактной фабрики и никому ее не показывать. Фабрика
использует команду switch для создания соответствующих экземпляров потомков Employee, а вызовы функций
calculatePay, isPayDay, deliverPay и т. д. проходят полиморфную передачу через интерфейс Employee.

```php
public abstract classEmployee {
    public abstract booleanisPayday();
    public abstract MoneycalculatePay();
    public abstract voiddeliverPay(Money pay);
}
-----------------
public interfaceEmployeeFactory {
    public EmployeemakeEmployee(EmployeeRecord r) 
      throws InvalidEmployeeType;
}
-----------------
public classEmployeeFactoryImplimplementsEmployeeFactory {
    public EmployeemakeEmployee(EmployeeRecord r)
       throws InvalidEmployeeType {
            switch (r.type) {
                case COMMISSIONED:
                   return new CommissionedEmployee(r) ;
                case HOURLY:
                   return new HourlyEmployee(r);
                case SALARIED:
                   return new SalariedEmploye(r);
                default:
                   throw new InvalidEmployeeType(r.type);
            }
      }
}
```

Мое общее правило в отношении команд switch гласит, что эти команды допустимы, если они встречаются в программе
однократно, используются для создания полиморфных объектов и скрываются за отношениями наследования, чтобы
оставаться невидимыми для остальных частей системы. Конечно, правил без исключений не бывает и в некоторых
ситуациях приходится нарушать одно или несколько условий этого правила.

7. `Используйте содержательные имена`

Не бойтесь использовать длинные имена Длинное содержательное имя лучше короткого невразумительного. Выберите
схему, которая позволяет легко прочитать слова в имени функции, а затем составьте из этих слов имя, которое
описывает назначение функции.

8. `Аргументы функций`

В идеальном случае количество аргументов функции равно нулю. Далее следуют функции с одним аргументом (унарные) и
с двумя аргументами (бинарные). Функций с тремя аргументами (тернарных) следует по возможности избегать.

Выходные аргументы запутывают ситуацию еще быстрее, чем входные. Как правило, никто не ожидает, что функция будет
возвращать информацию в аргументах. Если уж обойтись без аргументов никак не удается, постарайтесь хотя бы
ограничиться одним входным аргументом.

Преобразования, в которых вместо возвращаемого значения используется выходной аргумент, сбивают читателя с толку.
Если функция преобразует свой входной аргумент, то результат должен передаваться в возвращаемом значении.

9. `Аргументы-флаги`

Аргументы-флаги уродливы. Передача логического значения функции — воистину ужасная привычка. Она немедленно
усложняет сигнатуру метода, громко провозглашая, что функция выполняет более одной операции. При истинном значении
флага выполняется одна операция, а при ложном — другая.

10. `Бинарные функции`

Функцию с двумя аргументами понять сложнее, чем унарную функцию. Конечно, в некоторых ситуациях форма с двумя
аргументами оказывается уместной. Например, вызов Point p = new Point(0,0); абсолютно разумен. Однако два
аргумента в нашем случае являются упорядоченными компонентами одного значения.

11. `Объекты как аргументы`

Если функция должна получать более двух или трех аргументов, весьма вероятно, что некоторые из этих аргументов
стоит упаковать в отдельном классе. Рассмотрим следующие два объявления:

    ```php
    Circle makeCircle(double x,double y,double radius);
    Circle makeCircle(Point center,double radius);
    ```

Если переменные передаются совместно как единое целое (как переменные x и y в этом примере), то, скорее всего,
вместе они образуют концепцию, заслуживающую собственного имени.

12. `Глаголы и ключевые слова`

Выбор хорошего имени для функции способен в значительной мере объяснить смысл функции, а также порядок и смысл ее
аргументов. В унарных функциях сама функция и ее аргумент должны образовывать естественную пару
«глагол/существительное». Например, вызов вида write(name) смотрится весьма информативно.

Читатель понимает, что чем бы ни было «имя» (name), оно куда-то «записывается» (write). Еще лучше запись
writeField(name), которая сообщает, что «имя» записывается в «поле» какой-то структуры.

Последняя запись является примером использования ключевых слов в имени функции. В этой форме имена аргументов
кодируются в имени функции. Например, assertEquals можно записать в виде assertExpectedEqualsActual(expected,
actual). Это в значительной мере решает проблему запоминания порядка аргументов.

13. `Разделение команд и запросов`

Функция должна что-то делать или отвечать на какой-то вопрос, но не одновременно. Либо функция изменяет состояние
объекта, либо возвращает информацию об этом объекте. Совмещение двух операций часто создает путаницу.

14. `Изолируйте блоки try/catch`

Блоки try/catch выглядят весьма уродливо. Они запутывают структуру кода и смешивают обработку ошибок с нормальной
обработкой. По этой причине тела блоков try и catch рекомендуется выделять в отдельные функции и после не должно быть
ничего другого.

15. `Обработка ошибок как одна операция`

Функции должны выполнять одну операцию. Обработка ошибок — это одна операция. Значит, функция, обрабатывающая
ошибки, ничего другого делать не должна. Отсюда следует, что если в функции присутствует ключевое слово try, то
оно должно быть первым словом в функции, а после блоков catch/finally ничего другого быть не должно.

### Глава 5. Форматирование

> Цели форматирования - Стиль кодирования и удобочитаемость имеют большое влияние на сопровождаемость и расширяемость
> кода

- `Вертикальное разделение концепций`
  Строка = выражение, условие. Группа строк = законченная мысль. Мысли следует разделять пустыми строками.

- `Вертикальное упорядочение`
  Еще раз: от высоких абстракций к низким, от вызывающих функций к вызываемым.

- `Вертикальное сжатие`
  Вертикальное разрежение разделяет концепции, сжатие – наоборот, подчеркивает тесную связь.

- `Вертикальные расстояния`
  Связанные друг с другом концепции должны распологаться по соседству. Переменные объявлять как можно ближе к месту
  использования.

## Основные принципы структурирования кода

Взято из статьи (https://ru.hexlet.io/blog/posts/arhitektura-i-oop)

### Изолируйте побочные эффекты от чистого кода

Всё, что связано с вводом/выводом, должно быть не внутри, а, желательно, на самом верхнем уровне. Причём чаще всего в
начале работы программы происходит чтение необходимых данных, потом — большой блок основной логики (чистый код) и на
выходе — снова побочный эффект, например, запись в файл. В вебе это "запрос-ответ".

### Следите за идемпотентностью

Если операцию возможно реализовать так, что она может быть перезапущена в случае ошибки и это не приведёт к проблемам,
то операция должна быть реализована именно так. В первую очередь это относится к периодическим и асинхронным задачам.

### Используйте автоматное программирование

Программирование на флагах — индикатор кода, который нужно переписывать. Автоматы можно применять крайне широко.
Фактически, любой процесс, протекающий внутри системы — потенциальный конечный автомат. Например:

- Регистрация пользователя (ожидает подтверждения емейла, подтвержден, забанен)
- Публикация статьи (черновик, опубликованная, удаленная)

### Избегайте глобальных переменных.

Ими могут выступать и объекты, и классы, имеющие внутреннее состояние, которое может поменяться в процессе жизни
приложения.

### Избегайте ненужного состояния и разделяемого состояния (shared state)

Первое особенно часто проявляется тогда, когда объекты наделяются внутренним состоянием в ситуациях, где это не нужно.
Например, при сохранении промежуточных данных между разными вызовами. Используйте формальный метод для проверки того,
нужно ли в данной ситуации внутреннее состояние или нет. Проверьте, можно ли объект, выполняющий операцию, заменить
функцией? И если ответ "да" — то состояния (кроме конфигурации) быть не должно.

Выделяйте абстракции по необходимости
Одно из ключевых правил в обучении программированию: не делайте ничего лишнего до тех пор, пока не начнёт болеть.
Разбивайте и выделяйте, только когда почувствовали, что текущее положение дел мешает быть эффективным. Только в этом
случае придёт понимание, когда стоит что-то делать, а когда — нет. В ином случае очень легко перейти черту и
превратиться в "архитектурного астронавта" (overengineering)

- Нужно ли выносить функцию в отдельный файл? Нет.
- Нужно ли делать много маленьких функций? Нет.
- Нужно ли разбивать компонент на компоненты? Нет.
- Нужно ли вешать индекс в базу данных на всякий случай, ведь потом данных будет много? Нет.

Возможно, это контринтуитивно. Но гораздо проще изменять код, который находится в одном месте и не разбит на множество
мелких частей. Разбивать имеет смысл тогда, когда архитектура устаканилась и все граничные случаи учтены. А до этого
момента пусть оно будет неделимым.

### Изолируйте технический долг

Не любой технический долг растёт. Если абстракция хороша и не протекает, то не принципиально, как написан код внутри.
Его можно будет переписать, когда придёт время. Иногда приходит время — и код просто удаляется за ненадобностью. Простой
пример: функция сортировки массива.

### Разбивайте приложение на слои

Используйте уровневое проектирование (посмотрите модель OSI). Нижние слои не должны знать про сущности верхних слоев, а
верхние слои работают на базе нижних. Пример разбиения.

### Не ставьте производительность во главу угла

Перед тем как говорить про производительность, прочитайте [optimization.guide](https://optimization.guide/)

[⏏ К содержанию](#содержание)