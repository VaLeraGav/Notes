## XML
---

## Содержание

- [Введение](#введение)
- [Работа с XML](#работа-с-xml)
- [DTD](#dtd)
- [XML Schema (XSD)](#xml-schema)
- [XPath](#xpath)
    - [Поиск](#поиск)
    - [Операторы](#операторы)
    - [Предикаты](#предикаты)
    - [Выбор нескольких путей](#выбор-нескольких-путей)
    - [Оси](#оси)
    - [Выражения](#выражения)
- [XSLT](#xslt)

---

## Введение

`Пространство имён` в XML (англ. XML namespace) — это стандарт, описывающий именованную группу имён элементов и
атрибутов,
служащую для обеспечения их уникальности в XML-документе.

XML — используется в SOAP (всегда) и REST-запросах (реже);

Этот формат рекомендован Консорциумом Всемирной паутины (W3C), поэтому он часто используется для передачи данных
по `API`. В `SOAP API` это вообще единственно возможный формат входных и выходных данных!

## Работа с XML

`Meta` - цель, конечный пункт, предел, край и данные (латинское значение)

`Данные` - поддающееся многократной интерпретации представление информации в
формализованном виде, пригодном для передачи, связи или обработки (ISO/IEC 2382:2015) Метаданные - информация о другой
информации, или данные, относящиеся к
дополнительной информации о содержимом или объекте.

`Язык разметки` (markup language) - средство описания данных и метаданных, хранящихся в документе.
Назначение языков разметки заключается в описании структурированных документов,
причем в этом случае интерпретируется содержимое документа.

`XML` - eXtensible Markup Language ( Расширяемый язык разметки ) XML метаязык язык для описания языков разметки, xml не
привязан ни к одному языку программирования, операционной системе. XML обеспечивает доступ к большому количеству
технологий по манипулированию, структурированию, трансформированию и запрашиванию данных.

```xml
<!-- нотация -->
<?xml version='1.0' encoding='UTF-8'?>
<!--не обязательная часть, подключение стилей -->
<?xml-stylesheet type="text/xsl" href="books.xsl"?>
<!-- корневой тег -->
<worker>
    <!-- всегда есть закрывающиеся тег -->
    <!-- всегда имя начинаеться с буквы -->
    <name>Коля</name>
    <age>25</age>
    <salary>1000</salary>
    <!--  name="Коля" (атрибут) -->
    <!--  <worker>...</worker> (узел) -->
    <worker name="Коля" age="25" salary="1000">Номер 1</worker>
    <workers>
        <first-name>Сергей</first-name>
        <last-name>Иванов</last-name>
    </workers>
    <!--  раздел содержимого элемента, который помечен парсером для интерпретации -->
    <!-- только как символьные данные, а не как разметка -->
    <![CDATA[
        </fwf/afdf > : @ ' "" >< 
        читаеться как текст
    ]]>
</worker>

```

Давайте получим имя, возраст и зарплату работника:

```php
$xml = simplexml_load_file(путь к файлу или урл);
$xml->name; // 'Коля'
$xml->age; // 25

$xml->worker['name']; // 'Коля'

$xml->workers->{first-name}; // Сергей

var_dump(json_decode(json_encode($xml), true)); // Из объекта в массив
```

```xml

<univers:books xmlns:univer=" http://www.tnu.crimea.ua/ ">
    <univer:book>
        <univer:id>ASD345</univer:id>
        <univer:title>XSLT. Programmer's Reference
        </univer:title>
        <univer:name>Michael Kay</univer:name>
        <univer:year>2002
        </univer: year>
        <univer:descr>short book description</univer:descr>
    </univer:book>
</univer:books>
```

Сокращенная запись, чтобы не менять каждый тег.

````xml

<wrapper xmlns=" http://www.tnu.crimea.ua/ ">
    <books>
        <book>
            <id>ASD345</id>
            <title>XSLT. Programmer's Reference</title>
            <name>Michael Kay</name>
            <year>2002</year>
            <descr>short book description</descr>
        </book>
    </books>
</wrapper>
````

[⏏ К содержанию](#содержание)

## DTD

`DTD` - Заранее определённый свод правил, задающий связи между элементами и атрибутами.

```xml
<!DOCTYPE html
        PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" " http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd ">

<!-- определяет, что корневым элементом документа является note -->
<!DOCTYPE note [
        <!--  note содержит четыре элемента: to, from, heading, body -->
        <!ELEMENT note (to,from,heading,body)>
        <!-- books какое угодно количество book -->
        <!ELEMENT books (book*)>
        <!-- book обязательно имеет name, не обязательно author и year -->
        <!ELEMENT book (name, author?, year?)>
        <!-- name имеет какие то данные, должен быть типа "#PCDATA" -->
        <!ELEMENT name (#PCDATA) >
        <!ELEMENT author (#PCDATA) >
        <!ELEMENT year (#PCOATA) >
        ]>
```

Зачем нужно использовать DTD:

- С DTD ваш XML файл может нести собственный формат.
- С DTD различные, не связанные друг с другом группы людей могут приходить к соглашению о стандартах пересекающихся
  данных.
- С DTD вы можете быть уверены, что получаемые из внешних источников данные будут корректными.

Когда не стоит использовать DTD:

- Вообще-то для работы XML не требуется DTD.
- Когда вы экспериментируете с XML или работаете с небольшими XML файлами, то создание DTD может оказаться излишней
  тратой времени.

[⏏ К содержанию](#содержание)

## XML Schema

`XSD` (XML Schema Definition) — это описание вашего XML, также называют Определение схемы XML.
XML схема мощнее DTD.

Если мы создаем `SOAP-метод`, то указываем в схеме:

- какие поля будут в запросе;
- какие поля будут в ответе;
- какие типы данных у каждого поля;
- какие поля обязательны для заполнения, а какие нет;
- есть ли у поля значение по умолчанию, и какое оно;
- есть ли у поля ограничение по длине ...

Теперь, когда к нам приходит какой-то запрос, он сперва проверяется на корректность по схеме.

Зачем нужно использовать XML схему:

- С XML схемой ваш XML файл может нести собственный формат.
- С XML схемой различные, не связанные друг с другом группы людей могут приходить к соглашению о стандартах
  пересекающихся данных.
- С XML схемой вы можете проверять корректность данных.

Ниже приведен пример файла XML схемы "note.xsd", который определяет элементы XML документа, показанного ("note.xml"):

```xml
<?xml version="1.0"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
           targetNamespace="http://msiter.ru" xmlns="http://msiter.ru" elementFormDefault="qualified">
    <xs:element name="note">
        <xs:complexType>
            <xs:sequence>
                <xs:element name="to" type="xs:string"/>
                <xs:element name="from" type="xs:string"/>
                <xs:element name="heading" type="xs:string"/>
                <xs:element name="body" type="xs:string"/>
            </xs:sequence>
        </xs:complexType>
    </xs:element>
</xs:schema>
```

В следующем XML документе есть указание на подключение файла XML схемы:

```xml

<note xmlns="http://msiter.ru"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="http://msiter.ru note.xsd">
    <to>Tove</to>
    <from>Jani</from>
    <heading>Напоминание</heading>
    <body>Не забудь обо мне в эти выходные!</body>
</note>
```

[⏏ К содержанию](#содержание)

## XPath

Для навигации, вычисление выражений и поиска внутри XML используется язык запросов `XPath`.

```xml
<?xml version="1.0" encoding="UTF-8"?>
<bookstore>
    <book>
        <title lang="en">Harry Potter</title>
        <price>29.99</price>
    </book>
    <book>
        <title lang="en">Learning XML</title>
        <price>39.95</price>
    </book>
</bookstore>
```

### Поиск

| Выражение | Описание                                                                                                        |
|-----------|-----------------------------------------------------------------------------------------------------------------|
| имя_узла  | 	Выбирает все узлы с именем имя_узла                                                                            |
| /         | 	Выбирает от корневого узла                                                                                     |
| //        | Выбирает узлы в документе от текущего узла, который соответствует выбору, независимо от того, где они находятся |
| .         | Выбирает текущий узел                                                                                           |
| ..        | Выбирает родителя текущего узла                                                                                 |
| @         | Выбирает атрибуты                                                                                               |

| Выражение       | XPath	Результат                                                                                                                                            |
|-----------------|------------------------------------------------------------------------------------------------------------------------------------------------------------|
| bookstore       | Выбирает все узлы с именем "bookstore"                                                                                                                     |
| /bookstore      | Выбирает корневой элемент книжного магазинаПримечание: Если путь начинается с косой черты (/), он всегда представляет собой абсолютный путь к элементу!    |
| bookstore/book  | Выбирает все элементы «книга» (book), которые являются потомками элемента «книжный магазин» (bookstore)                                                    |
| //book          | Выбирает все элементы «книга» независимо от того, где они находятся в документе                                                                            |
| bookstore//book | Выбирает все элементы «книга», которые являются потомком элемента «книжный магазин», независимо от того, где они находятся под элементом «книжный магазин» |
| //@lang         | Выбирает все атрибуты, которые называются "lang"                                                                                                           |

[⏏ К содержанию](#содержание)

### Операторы

Выражения XPath возвращают как набор узлов, строки, булевы или числовые значения. Ниже представлен список операторов,
используемых в выражениях XPath:

| Оператор | Описание                   | Пример                    |
|----------|----------------------------|---------------------------|
| &#124;   | Вычисляет два набора узлов | //book &#124; //cd        |
| +	       | Сложение                   | 6 + 4                     |
| -	       | Вычитание                  | 6 - 4                     |
| *	       | Умножение                  | 6 * 4                     |
| div      | Деление                    | 8 div 4                   |
| =        | Равенство	                 | price=9.80                |
| !=       | Неравенство                | price!=9.80               |
| <        | Меньше, чем                | price<9.80                |
| <=       | Меньше или равно           | price≤9.80                |
| 	&lt;    | Больше, чем	               | price>9.80                |
| 	&lt;=	  | Больше или равно           | price≤9.80                |
| or	      | Или                        | price=9.80 or price=9.70  |
| and	     | И	                         | price>9.00 and price<9.90 |
| mod	     | Остаток от деления         | 5 mod 2                   |

[⏏ К содержанию](#содержание)

### Предикаты

Предикаты используются для поиска (фильтрации) специфического узла или узла, который содержит специфическое значение.
Предикаты
всегда обрамляются квадратными скобками.

| Выражения XPath                    | Результат       |
|------------------------------------|------------------------------------------------------------|
| /bookstore/book[1]                 | Выбирает первый элемент «книга», который является потомком элемента «книжный магазин». Примечание: В IE 5,6,7,8,9 первый узел имеет индекс [0], но в соответствии с рекомендациями W3C, это [1]. Для решения этой проблемы в IE, задаётся опция "SelectionLanguage" для XPath: На JavaScript: xml.setProperty("SelectionLanguage", "XPath"); |
| /bookstore/book[last()]            | Выбирает последний элемент «книга» (book), который является дочерним элементом элемента «книжный магазин» (bookstore) |
| /bookstore/book[last()-1]          | Выбирает предпоследний элемент «книга», который является дочерним элементом элемента «книжный магазин» |
| /bookstore/book[position()<3]      | Выбор первых двух элементов «книга», которые являются потомками элемента «книжный магазин»|
| //title[@lang]                     | Выбирает все элементы «название» (title), которые имеют атрибут с именем "lang"  |
| //title[@lang='en']                | Выбирает все элементы «название», которые имеют атрибут «язык» со значением "en" |
| /bookstore/book[price>35.00]       | Выбирает все элементы «книга» после элемента «книжный магазин», которые имеют элемент «цена» со значением больше, чем 35.00 |
| /bookstore/book[price>35.00]/title | Выбирает все элементы «название» книги элемента «книжный магазин», которые имеют элемент «цена» со значением больше, чем 35.00 |
| /bookstore/book[@class='list']     | Выбирает все элементы c классов list |

В XPath индексы элементов начинаются с единицы, а не с нуля, как в принятых стандартах программирования. Если вы уже
программируете, это может немного запутать.

### Выбор неизвестных узлов

| Wildcard | Описание                              |
|----------|---------------------------------------|
| *	       | Соответствует любому узлу             |
| @*       | Соответствует узлу-атрибуту           |
| node()   | Соответствует любому узлу любого типа |

В приведённой ниже таблице мы перечислили некоторые пути выражения и результаты выражений:

| Выражение пути | Результат                                                                                        |
|----------------|--------------------------------------------------------------------------------------------------|
| /bookstore/*   | Выбирает все дочерние узлы элемента «книжный магазин» (bookstore)                                |
| //*            | Выбирает все элементы в документе                                                                |
| //title[@*]    | Выбирает все элементы «название» (title), которые имеют по крайней мере один атрибут любого вида |

[⏏ К содержанию](#содержание)

### Выбор нескольких путей

С помощью оператора | в выражениях XPath вы можете выбрать несколько путей. В таблице ниже перечислены несколько
выражений путей и результаты их применения:

| Выражение пути                       | Результат                                                                                                      |
|--------------------------------------|----------------------------------------------------------------------------------------------------------------|
| //book/title &#124; //book/price     | Выбирает все элементы «название» (title) И «цена» (price) всех элементов «книга» (book)                        |
| //title &#124; //price               | Выбирает все элементы «название» (title) И «цена» (price) в документе                                          |
| /bookstore/book/title &#124; //price | Выбирает все элементы «название» элемента «книга» элемента «книжный магазин» И все элементы «цена» в документе |

### Оси

Для навигации по иерархическому дереву узлов в XML-документе XPath использует концепцию осей. Спецификация XPath
определяет в общей сложности 13 различных осей, которые мы изучим в этом разделе.

Ось `XPath` — это набор узлов, удовлетворяющих текущим критериям навигации.

Мы будем использовать следующий XML документ далее в примере.

```xml
<?xml version="1.0" encoding="UTF-8"?>
<bookstore>
    <book>
        <title lang="en">Harry Potter</title>
        <price>29.99</price>
    </book>
    <book>
        <title lang="en">Learning XML</title>
        <price>39.95</price>
    </book>
</bookstore>
```

| Название оси       | Результат                                                                                                                               |
|--------------------|-----------------------------------------------------------------------------------------------------------------------------------------|
| ancestor           | Выбирает всех предков (родителей, прародителей и т.д.) текущего узла                                                                    |
| ancestor-or-self   | Выбирает всех предков (родителей, прародителей и т.д.) текущего узла и сам текущий узел                                                 |
| attribute          | Выбирает все атрибуты текущего узла                                                                                                     |
| child              | Выбирает всех потомков текущего узла                                                                                                    |
| descendant         | Выбирает всех потомков (детей, внуков и т.д.) текущего узла                                                                             |
| descendant-or-self | Выбирает всех потомков (детей, внуков и т.д.) текущего узла и сам текущий узел                                                          |
| following          | Выбирает всё в документе после закрытия тэга текущего узла                                                                              |
| following-sibling  | Выбирает все узлы одного уровня после текущего узла                                                                                     |
| namespace          | Выбирает все узлы в данном пространстве имён (namespace) текущего узла                                                                  |
| parent             | Выбирает родителя текущего узла                                                                                                         |
| preceding          | Выбирает все узлы, которые появляются перед текущим узлом в документе, за исключением предков, узлов атрибутов и узлы пространства имён |
| preceding-sibling  | Выбирает всех братьев и сестёр до текущего узла                                                                                         |
| self               | Выбирает текущий узел                                                                                                                   |

```
Syntax:
  //preceding::tagName
```

[⏏ К содержанию](#содержание)

### Выражения

Путь определения местоположения может быть абсолютным или относительным. Абсолютный путь расположения начинается с косой
черты (/), а относительный – нет. В обоих случаях путь выборки состоит из одного или нескольких шагов, разделённых косой
чертой:

`/step/step/` - Абсолютный путь расположения

`step/step/...` - Относительный путь выборки расположения

Каждый шаг оценивается по узлам в текущем наборе узлов. Шаг состоит из:

- ось (определяет древовидную связь между выбранными узлами и текущим узлом);
- проверка узла (идентифицирует узел в пределах оси);
- ноль или более предикатов (для дальнейшего уточнения выбранного набор узлов)

| Пример                 | Результат                                                                                         |
|------------------------|---------------------------------------------------------------------------------------------------|
| child::book            | Выбирает все узлы «книга» (book), которые являются потомками текущего узла                        |
| attribute::lang        | Выбирает атрибут «язык» (lang) текущего узла                                                      |
| child::*               | Выбирает всех потомков текущего узла                                                              |
| attribute::*           | Выбирает все атрибуты текущего узла                                                               |
| child::text()          | Выбирает все текстовые узлы текущего узла                                                         |
| child::node()          | Выбирает всех ближайших потомков текущего узла                                                    |
| descendant::book       | Выбирает всех потомков текущего узла                                                              |
| ancestor::book         | Выбирает всех предков «книга» (books) текущего узла                                               |
| ancestor-or-self::book | Выбирает всех предков «книга» (book) текущего узла – и текущий узел, если он также «книга» (book) |
| child::*/child::price  | Выбирает все потомки «цена» (price) через один уровень от текущего узл                            |

[Введение в XPath | hexlet](https://guides.hexlet.io/ru/xpath/)

[⏏ К содержанию](#содержание)

## XSLT

[Документация XSLT 1.0]https://xsltdev.ru/tr/

`XSLT` (eXtensible Stylesheet Language Transformations) — язык преобразования XML-документов (шаблон). Спецификация XSLT
входит в состав XSL и является рекомендацией W3C.

```
Входной XML-документ
         |
        XSLT
         |
         |---> XML
         |--> XHTML
         |---> JSON
         |--> TEXT
```

```
<xsl:template match="page">
    <html>
        <head>
            <title>
                <xsl:value-of select="etitle"/>
            </title>
        </head>
        <body>
              <xsl:if test="@name - " index"">
              <xsl:attribute name="class">index</xsl:attribute>
            </xsl:if>
            <xsl:apply-templates/>
        </body>
    </html>
</xsl:template>
```

Пример использования XML+XSLT:

```xml
<!-- index. xml -->
<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="index.xsl"?>
<page>Page Title</page>
```  

```xml
<!-- index.xsl-->
<?xml version="1.0" encoding="utf-8"?>
<xsl:stylesheet xmlns:xsl="..." version="1.0">
    <xsl:template match="/">
        <h1>
            <xsl:value-of select="page"/>
        </h1>
    </xsl:template>
</xsl:stylesheet>
```

[⏏ К содержанию](#содержание)